<!DOCTYPE html>

<html>
  <head>
    <title>Protocol Documentation</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>
    <style>
      body {
        width: 60em;
        margin: 1em auto;
        color: #222;
        font-family: "Ubuntu", sans-serif;
        padding-bottom: 4em;
      }

      h1 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      h2 {
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
        margin: 1.5em 0;
      }

      h3 {
        font-weight: normal;
        border-bottom: 1px solid #aaa;
        padding-bottom: 0.5ex;
      }

      a {
        text-decoration: none;
        color: #567e25;
      }

      table {
        width: 100%;
        font-size: 80%;
        border-collapse: collapse;
      }

      thead {
        font-weight: 700;
        background-color: #dcdcdc;
      }

      tbody tr:nth-child(even) {
        background-color: #fbfbfb;
      }

      td {
        border: 1px solid #ccc;
        padding: 0.5ex 2ex;
      }

      td p {
        text-indent: 1em;
        margin: 0;
      }

      td p:nth-child(1) {
        text-indent: 0;  
      }

       
      .field-table td:nth-child(1) {  
        width: 10em;
      }
      .field-table td:nth-child(2) {  
        width: 10em;
      }
      .field-table td:nth-child(3) {  
        width: 6em;
      }
      .field-table td:nth-child(4) {  
        width: auto;
      }

       
      .extension-table td:nth-child(1) {  
        width: 10em;
      }
      .extension-table td:nth-child(2) {  
        width: 10em;
      }
      .extension-table td:nth-child(3) {  
        width: 10em;
      }
      .extension-table td:nth-child(4) {  
        width: 5em;
      }
      .extension-table td:nth-child(5) {  
        width: auto;
      }

       
      .enum-table td:nth-child(1) {  
        width: 10em;
      }
      .enum-table td:nth-child(2) {  
        width: 10em;
      }
      .enum-table td:nth-child(3) {  
        width: auto;
      }

       
      .scalar-value-types-table tr {
        height: 3em;
      }

       
      #toc-container ul {
        list-style-type: none;
        padding-left: 1em;
        line-height: 180%;
        margin: 0;
      }
      #toc > li > a {
        font-weight: bold;
      }

       
      .file-heading {
        width: 100%;
        display: table;
        border-bottom: 1px solid #aaa;
        margin: 4em 0 1.5em 0;
      }
      .file-heading h2 {
        border: none;
        display: table-cell;
      }
      .file-heading a {
        text-align: right;
        display: table-cell;
      }

       
      .badge {
        width: 1.6em;
        height: 1.6em;
        display: inline-block;

        line-height: 1.6em;
        text-align: center;
        font-weight: bold;
        font-size: 60%;

        color: #89ba48;
        background-color: #dff0c8;

        margin: 0.5ex 1em 0.5ex -1em;
        border: 1px solid #fbfbfb;
        border-radius: 1ex;
      }
    </style>

    
    <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
  </head>

  <body>

    <h1 id="title">Protocol Documentation</h1>

    <h2>Table of Contents</h2>

    <div id="toc-container">
      <ul id="toc">
        
          
          <li>
            <a href="#conformance%2fconformance.proto">conformance/conformance.proto</a>
            <ul>
              
                <li>
                  <a href="#conformance.ConformanceRequest"><span class="badge">M</span>ConformanceRequest</a>
                </li>
              
                <li>
                  <a href="#conformance.ConformanceResponse"><span class="badge">M</span>ConformanceResponse</a>
                </li>
              
                <li>
                  <a href="#conformance.FailureSet"><span class="badge">M</span>FailureSet</a>
                </li>
              
                <li>
                  <a href="#conformance.JspbEncodingConfig"><span class="badge">M</span>JspbEncodingConfig</a>
                </li>
              
              
                <li>
                  <a href="#conformance.TestCategory"><span class="badge">E</span>TestCategory</a>
                </li>
              
                <li>
                  <a href="#conformance.WireFormat"><span class="badge">E</span>WireFormat</a>
                </li>
              
              
              
            </ul>
          </li>
        
        <li><a href="#scalar-value-types">Scalar Value Types</a></li>
      </ul>
    </div>

    
      
      <div class="file-heading">
        <h2 id="conformance/conformance.proto">conformance/conformance.proto</h2><a href="#title">Top</a>
      </div>
      <p></p>

      
        <h3 id="conformance.ConformanceRequest">ConformanceRequest</h3>
        <p>Represents a single test case's input.  The testee should:</p><p>1. parse this proto (which should always succeed)</p><p>2. parse the protobuf or JSON payload in "payload" (which may fail)</p><p>3. if the parse succeeded, serialize the message in the requested format.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>protobuf_payload</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p> </p></td>
                </tr>
              
                <tr>
                  <td>json_payload</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p> </p></td>
                </tr>
              
                <tr>
                  <td>jspb_payload</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>Only used inside Google.  Opensource testees just skip it. </p></td>
                </tr>
              
                <tr>
                  <td>text_payload</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p> </p></td>
                </tr>
              
                <tr>
                  <td>requested_output_format</td>
                  <td><a href="#conformance.WireFormat">WireFormat</a></td>
                  <td></td>
                  <td><p>Which format should the testee serialize its message to? </p></td>
                </tr>
              
                <tr>
                  <td>message_type</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>The full name for the test message to use; for the moment, either:
protobuf_test_messages.proto3.TestAllTypesProto3 or
protobuf_test_messages.google.protobuf.TestAllTypesProto2. </p></td>
                </tr>
              
                <tr>
                  <td>test_category</td>
                  <td><a href="#conformance.TestCategory">TestCategory</a></td>
                  <td></td>
                  <td><p>Each test is given a specific test category. Some category may need
specific support in testee programs. Refer to the definition of
TestCategory for more information. </p></td>
                </tr>
              
                <tr>
                  <td>jspb_encoding_options</td>
                  <td><a href="#conformance.JspbEncodingConfig">JspbEncodingConfig</a></td>
                  <td></td>
                  <td><p>Specify details for how to encode jspb. </p></td>
                </tr>
              
                <tr>
                  <td>print_unknown_fields</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>This can be used in json and text format. If true, testee should print
unknown fields instead of ignore. This feature is optional. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="conformance.ConformanceResponse">ConformanceResponse</h3>
        <p>Represents a single test case's output.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>parse_error</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>This string should be set to indicate parsing failed.  The string can
provide more information about the parse error if it is available.

Setting this string does not necessarily mean the testee failed the
test.  Some of the test cases are intentionally invalid input. </p></td>
                </tr>
              
                <tr>
                  <td>serialize_error</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>If the input was successfully parsed but errors occurred when
serializing it to the requested output format, set the error message in
this field. </p></td>
                </tr>
              
                <tr>
                  <td>timeout_error</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>This should be set if the test program timed out.  The string should
provide more information about what the child process was doing when it
was killed. </p></td>
                </tr>
              
                <tr>
                  <td>runtime_error</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>This should be set if some other error occurred.  This will always
indicate that the test failed.  The string can provide more information
about the failure. </p></td>
                </tr>
              
                <tr>
                  <td>protobuf_payload</td>
                  <td><a href="#bytes">bytes</a></td>
                  <td></td>
                  <td><p>If the input was successfully parsed and the requested output was
protobuf, serialize it to protobuf and set it in this field. </p></td>
                </tr>
              
                <tr>
                  <td>json_payload</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>If the input was successfully parsed and the requested output was JSON,
serialize to JSON and set it in this field. </p></td>
                </tr>
              
                <tr>
                  <td>skipped</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>For when the testee skipped the test, likely because a certain feature
wasn&#39;t supported, like JSON input/output. </p></td>
                </tr>
              
                <tr>
                  <td>jspb_payload</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>If the input was successfully parsed and the requested output was JSPB,
serialize to JSPB and set it in this field. JSPB is only used inside
Google. Opensource testees can just skip it. </p></td>
                </tr>
              
                <tr>
                  <td>text_payload</td>
                  <td><a href="#string">string</a></td>
                  <td></td>
                  <td><p>If the input was successfully parsed and the requested output was
TEXT_FORMAT, serialize to TEXT_FORMAT and set it in this field. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="conformance.FailureSet">FailureSet</h3>
        <p>The conformance runner will request a list of failures as the first request.</p><p>This will be known by message_type == "conformance.FailureSet", a conformance</p><p>test should return a serialized FailureSet in protobuf_payload.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>failure</td>
                  <td><a href="#string">string</a></td>
                  <td>repeated</td>
                  <td><p> </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      
        <h3 id="conformance.JspbEncodingConfig">JspbEncodingConfig</h3>
        <p>Encoding options for jspb format.</p>

        
          <table class="field-table">
            <thead>
              <tr><td>Field</td><td>Type</td><td>Label</td><td>Description</td></tr>
            </thead>
            <tbody>
              
                <tr>
                  <td>use_jspb_array_any_format</td>
                  <td><a href="#bool">bool</a></td>
                  <td></td>
                  <td><p>Encode the value field of Any as jspb array if true, otherwise binary. </p></td>
                </tr>
              
            </tbody>
          </table>

          

        
      

      
        <h3 id="conformance.TestCategory">TestCategory</h3>
        <p></p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>UNSPECIFIED_TEST</td>
                <td>0</td>
                <td><p></p></td>
              </tr>
            
              <tr>
                <td>BINARY_TEST</td>
                <td>1</td>
                <td><p>Test binary wire format.</p></td>
              </tr>
            
              <tr>
                <td>JSON_TEST</td>
                <td>2</td>
                <td><p>Test json wire format.</p></td>
              </tr>
            
              <tr>
                <td>JSON_IGNORE_UNKNOWN_PARSING_TEST</td>
                <td>3</td>
                <td><p>Similar to JSON_TEST. However, during parsing json, testee should ignore
unknown fields. This feature is optional. Each implementation can decide
whether to support it.  See
https://developers.google.com/protocol-buffers/docs/proto3#json_options
for more detail.</p></td>
              </tr>
            
              <tr>
                <td>JSPB_TEST</td>
                <td>4</td>
                <td><p>Test jspb wire format. Only used inside Google. Opensource testees just
skip it.</p></td>
              </tr>
            
              <tr>
                <td>TEXT_FORMAT_TEST</td>
                <td>5</td>
                <td><p>Test text format. For cpp, java and python, testees can already deal with
this type. Testees of other languages can simply skip it.</p></td>
              </tr>
            
          </tbody>
        </table>
      
        <h3 id="conformance.WireFormat">WireFormat</h3>
        <p></p>
        <table class="enum-table">
          <thead>
            <tr><td>Name</td><td>Number</td><td>Description</td></tr>
          </thead>
          <tbody>
            
              <tr>
                <td>UNSPECIFIED</td>
                <td>0</td>
                <td><p></p></td>
              </tr>
            
              <tr>
                <td>PROTOBUF</td>
                <td>1</td>
                <td><p></p></td>
              </tr>
            
              <tr>
                <td>JSON</td>
                <td>2</td>
                <td><p></p></td>
              </tr>
            
              <tr>
                <td>JSPB</td>
                <td>3</td>
                <td><p>Only used inside Google. Opensource testees just skip it.</p></td>
              </tr>
            
              <tr>
                <td>TEXT_FORMAT</td>
                <td>4</td>
                <td><p></p></td>
              </tr>
            
          </tbody>
        </table>
      

      

      
    

    <h2 id="scalar-value-types">Scalar Value Types</h2>
    <table class="scalar-value-types-table">
      <thead>
        <tr><td>.proto Type</td><td>Notes</td><td>C++</td><td>Java</td><td>Python</td><td>Go</td><td>C#</td><td>PHP</td><td>Ruby</td></tr>
      </thead>
      <tbody>
        
          <tr id="double">
            <td>double</td>
            <td></td>
            <td>double</td>
            <td>double</td>
            <td>float</td>
            <td>float64</td>
            <td>double</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="float">
            <td>float</td>
            <td></td>
            <td>float</td>
            <td>float</td>
            <td>float</td>
            <td>float32</td>
            <td>float</td>
            <td>float</td>
            <td>Float</td>
          </tr>
        
          <tr id="int32">
            <td>int32</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="int64">
            <td>int64</td>
            <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="uint32">
            <td>uint32</td>
            <td>Uses variable-length encoding.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int/long</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="uint64">
            <td>uint64</td>
            <td>Uses variable-length encoding.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint32">
            <td>sint32</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sint64">
            <td>sint64</td>
            <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="fixed32">
            <td>fixed32</td>
            <td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td>
            <td>uint32</td>
            <td>int</td>
            <td>int</td>
            <td>uint32</td>
            <td>uint</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="fixed64">
            <td>fixed64</td>
            <td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td>
            <td>uint64</td>
            <td>long</td>
            <td>int/long</td>
            <td>uint64</td>
            <td>ulong</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="sfixed32">
            <td>sfixed32</td>
            <td>Always four bytes.</td>
            <td>int32</td>
            <td>int</td>
            <td>int</td>
            <td>int32</td>
            <td>int</td>
            <td>integer</td>
            <td>Bignum or Fixnum (as required)</td>
          </tr>
        
          <tr id="sfixed64">
            <td>sfixed64</td>
            <td>Always eight bytes.</td>
            <td>int64</td>
            <td>long</td>
            <td>int/long</td>
            <td>int64</td>
            <td>long</td>
            <td>integer/string</td>
            <td>Bignum</td>
          </tr>
        
          <tr id="bool">
            <td>bool</td>
            <td></td>
            <td>bool</td>
            <td>boolean</td>
            <td>boolean</td>
            <td>bool</td>
            <td>bool</td>
            <td>boolean</td>
            <td>TrueClass/FalseClass</td>
          </tr>
        
          <tr id="string">
            <td>string</td>
            <td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td>
            <td>string</td>
            <td>String</td>
            <td>str/unicode</td>
            <td>string</td>
            <td>string</td>
            <td>string</td>
            <td>String (UTF-8)</td>
          </tr>
        
          <tr id="bytes">
            <td>bytes</td>
            <td>May contain any arbitrary sequence of bytes.</td>
            <td>string</td>
            <td>ByteString</td>
            <td>str</td>
            <td>[]byte</td>
            <td>ByteString</td>
            <td>string</td>
            <td>String (ASCII-8BIT)</td>
          </tr>
        
      </tbody>
    </table>
  </body>
</html>

